# -*- coding: utf-8 -*-
"""ECE1513 Assignment 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Kvl6sora7zPA3BsLZtlg6IGN-lFg3w_
"""

# Import needed Libraries
import numpy as np
from sklearn.datasets import load_breast_cancer
import matplotlib.pyplot as plt

def kmeans(dataset, k, max_iters=100):
    min_values = dataset.min(axis=0)
    max_values = dataset.max(axis=0)
    centroids = np.random.uniform(min_values, max_values, size=(k, dataset.shape[1]))

    for iter in range(max_iters):
        # Compute the distance of each data point to all centroids
        distances = np.linalg.norm(dataset[:, np.newaxis, :] - centroids, axis=2)

        # Assign each data point to the nearest centroid
        assignments = np.argmin(distances, axis=1)

        # Initialize new centroids
        new_centroids = np.zeros_like(centroids)
        for i in range(k):
            assigned_points = dataset[assignments == i]
            if len(assigned_points) > 0:
                new_centroids[i] = assigned_points.mean(axis=0)
            else:
                # Reinitialize the centroid if no points are assigned
                new_centroids[i] = np.random.uniform(min_values, max_values, size=dataset.shape[1]) # Code was giving an error higher k's

        # Check for convergence
        if np.all(new_centroids == centroids):
            break

        centroids = new_centroids

    return centroids, assignments

def compute_distortion(dataset, centroids, assignments): #Compute Distortion
    distances = np.linalg.norm(dataset[:, np.newaxis, :] - centroids, axis=2) # Find distance between centroids and data assignments
    distortion = np.sum(np.min(distances, axis=1)**2)
    return distortion

# Load Data
data = load_breast_cancer()
X = data.data

# Intialize k and algo
k = 2
centroids, assignments = kmeans(X, k)

# Define the range of k values
k_values = range(2,8)

# List to store distortion values for each k
distortions = []

# Calculate distortion for each k in the defined range
for k in k_values:
    # Perform k-means clustering
    centroids, assignments = kmeans(X, k)

    # Calculate the distortion for the current k
    distortion = compute_distortion(X, centroids, assignments)

    # Append the distortion to the list
    distortions.append(distortion)

# Plot the distortions
plt.figure(figsize=(8, 6))
plt.plot(k_values, distortions, marker='o')
plt.xlabel('Number of Clusters (k)')
plt.ylabel('Distortion')
plt.title('Distortion vs Number of Clusters')
plt.grid(True)
plt.show()

"""4, I would likely choose 4 clusters as the optimal number. In the figure above, you can see that the distortion decreases significantly as the number of clusters increases from 2 to 7. However, the reduction in distortion from 4 to 7 clusters is minimal. Since this applies to real-world applications, itâ€™s important to balance computational efficiency with minimizing distortion. Given that the difference in distortion between 4 and higher cluster numbers (5, 6, and 7) is negligible, selecting 4 clusters would be the most efficient and practical choice."""
